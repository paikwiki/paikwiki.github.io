---
layout: post
title: 42서울 교육과정 3서클 libasm 학습 노트
date: 2020-12-15
tags: [42seoul, forty-two, 42cursus]
---

42서울 본과정의 세 번째 서클에 포함된 프로젝트, libasm을 진행하며 작성 중인 메모입니다.

## 어셈블리(Assembly)란?

본 챕터는 [유튜브 놀리팝의 어셈블리](https://www.youtube.com/watch?v=yf7yFJHTif8&t=37s&ab_channel=KnowlliPop%EB%86%80%EB%A6%AC%ED%8C%9D)를 참고하여 정리한 내용입니다.

기계어 라인 하나를 어셈블리 라인 하나에 대응되도록 만든 저수준 언어(low level language). 컴퓨터에 명령을 직접 내리므로 빠르고 정확한 처리가 가능하다. 리버스 엔지니어링이나, 시스템 해킹 등에도 자주 쓰인다.

### 어셈블리의 대표적인 문법

- AT&T와 Intel 문법

인텔 문법의 특징은 아래와 같다.

```asm
ADD Operand1, Operand2
```

위와 같은 코드에서 인텔 문법은 Operand1이 Destination, Operand2가 Source이다. 인텔 문법은 숫자나 레지스터명을 사용할 때 그 값을 그대로 사용하지만, AT&T문법은 Prefix가 붙는다. 또한 메모리 주소를 표기하는 방법도 다르다. 자세한 비교는 생략하고, 학습에는 인텔 문법을 사용할 것이다.

### 레지스터 종류

- AX(Accumulator Register): 덧셈/뺄셈의 연산에 주로 사용. C언어 프로그램의 리턴값을 저장
- BX(Base Register): 연산에 주로 사용하지만, 리턴값을 저장하지 않는다는 점에서 AX와 차이가 있다.
- CX(Counter Register): 숫자를 세는 레지스터. 반복하는 수로부터 1만큼 감소하며 동작한다.
- DX(Data Register): AX, BX, CX 등이 부족할 때 주로 사용하는 여분의 레지스터
- SI(Source Index): 데이터를 복사할 때 원본(source)의 주소를 저장하는 레지스터
- DI(Destination Index): 데이터를 복사할 때 복사한 값이 저장될(destination) 주소를 저장하는 레지스터
- SP(Stack Pointer): 스택프레임(StackFrame)의 끝지점 주소를 저장
- BP(Base Pointer): 스택프레임의 시작지점 주소를 저장

위의 레지스터는 16비트 아키텍처의 레지스터들로써, 32비트 아키텍처에는 앞에 "E"가, 64비트 아키텍쳐에는 "R"이 붙는다. 과제는 64비트 아키텍처를 기준으로 한다. 따라서 앞으로 코드에서는 "RAX", "RBX"처럼 "R"을 붙여 사용한다.

64비트에는 R8부터  R15까지 8개의 레지스터가 더 있다. 이 레지스터는 앞의 레지스터들과는 달리 이름이 없고 번호만 갖고 있다.

#### 레지스터의 이름

| 8-byte register | Bytes 0-3 | Bytes 0-1 | Byte 0 |
|-----------------|-----------|-----------|--------|
| %rax            | %eax      | %ax       | %al    |
| %rcx            | %ecx      | %cx       | %cl    |
| %rdx            | %edx      | %dx       | %dl    |
| %rbx            | %ebx      | %bx       | %bl    |
| %rsi            | %esi      | %si       | %sil   |
| %rdi            | %edi      | %di       | %dil   |
| %rsp            | %esp      | %sp       | %spl   |
| %rbp            | %ebp      | %bp       | %bpl   |
| %r8             | %r8d      | %r8w      | %r8b   |
| %r9             | %r9d      | %r9w      | %r9b   |
| %r10            | %r10d     | %r10w     | %r10b  |
| %r11            | %r11d     | %r11w     | %r11b  |
| %r12            | %r12d     | %r12w     | %r12b  |
| %r13            | %r13d     | %r13w     | %r13b  |
| %r14            | %r14d     | %r14w     | %r14b  |
| %r15            | %r15d     | %r15w     | %r15b  |

(표 출처 - [x64 Cheat Sheet](http://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf))

마치 영어 공부할 때, "현재 - 과거 - 과거분사"로 동사의 변형을 외우던 것처럼, 몇 비트 레지스터에 접근하지는지에 따라 이름이 특정 규칙에 맞춰 바뀌는 것을 볼 수 있다. 아래는 `8바이트` -> `4바이트` -> `2바이트` -> `1바이트` 레지스터의 이름을 형태별로 그룹지어본 목록이다.

- `%r_x` 형태: `%e_x` -> `%_x` -> `%_l`
- `%r_i` 형태: `%e_i` -> `%_i` -> `%_il`
- `%r_p` 형태: `%e_p` -> `%_p` -> `%_pl`
- `%rN` 형태: `%rNd` -> `%rNw` -> `%rNb`

`%r_i` 형태는 인덱스를 위한 레지스터임을 가리키기 위해 `i`가 계속 이름에 따라붙는다. 마찬가지로 `%r_p` 형태도 포인터를 위한 레지스터이므로 `p`를 계속 표기해준다. 그 외에 이름이 없이 번호로 구분하는 `%rN` 형태의 레지스터는 각각 뒤에 해당 레지스터의 크기를 `d`(DWORD), `w`(WORD), `b`(BYTE)로 표기해준다. 그럼 다른 유형에서 `l`은 무엇일까? `l`은 "LOW"를 의미한다. 이는 2바이트 크기에서 좌우 1바이트를 각각 "HIGH"와 "LOW"로 나눈 것이다. 예를 들면 `rdx`의 절반 크기가 `edx`, 그리고 그것보다 절반 작은 크기의 레지스터는 `dx`다. 이 2바이트 크기의 `dx`에서, 우측 절반 1바이트는 `dh`, 남은 좌측 절반이 `dl`이다.

이름이 중요한 건 아니다. 그냥 암기하려면 힘드니까 이해를 돕기 위해 서술해봤다.

### 기초 명령어

- PUSH/POP: 스택에 갑을 넣고/가져오는 명령어
- MOV: 값을 넣는 명령어
- LEA: MOV처럼 값을 넣는 명령어지만, 값 대신 주소를 넣는다.
- ADD/SUB: 더하고/빼는 명령어
- INC/DEC: 값을 증가시키고/감소시키는 명령어
- CMP: 두 값을 비교하는 명령어
- CALL: 함수를 호출하는 명령어
- RET: 호출한 함수를 종료하고 호출한 다음 줄로 이동시키는 명령어
- NOP: 아무 것도 하지 않는 명령어

### 인자의 순서

함수로부터 인자를 받을 때, 인자는 순서대로 각각 아래처럼 래지스터에 등록된다.

```txt
rdi, rsi, rdx, rcx, r8, r9
```

## 짧은 정보

- `ssize_t`:  signed size type으로 보통의 32bit machine에서는 간단히 말해 int다. IO 함수의 반환값으로 많이 사용되는데 그 이유는 해당 IO 함수의 실패를 알려주기 위해서이다.

## 참고 링크

### 웹페이지

- [TRADER TOM'S - Introduction to Computer Systems](https://brown-cs0330.github.io/website/index.html)
- [x86 어셈블리 기초 _ 메모리, 주소 접근 모드](https://live2skull.tistory.com/16)
- [[어셈블리] 범용 레지스터, 세그먼트 레지스터, 포인터 레지스터, 인덱스 레지스터, 플래그 레지스터](https://karfn84.tistory.com/entry/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%9D%98-%EA%B8%B0%EB%8A%A5)
- [[libasm] 어셈블리 프로그램 구조와 x64 레지스터 이해하기](https://velog.io/@hidaehyunlee/libasm-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4%EC%99%80-x64-%EB%B2%94%EC%9A%A9%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EC%A2%85%EB%A5%98)
- [x86_64 NASM Assembly Quick Reference ("Cheat Sheet")](https://www.cs.uaf.edu/2017/fall/cs301/reference/x86_64.html)
- [HS_University/REVERSING/asem](https://www.hackerschool.org/Sub_Html/HS_University/REVERSING/asem.html)

### PDF

- [x64 Cheat Sheet](http://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf)
### 동영상 강의

- [놀리팝 - 리버싱과 시스템 해킹을 공부하려면 꼭 알아야하는 어셈블리어의 기초[어셈블리어]](https://www.youtube.com/watch?v=yf7yFJHTif8&t=37s&ab_channel=KnowlliPop%EB%86%80%EB%A6%AC%ED%8C%9D)
- [놀리팝 - [실습편] 리버싱과 시스템 해킹을 공부하려면 꼭 알아야하는 어셈블리어의 기초 [어셈블리 언어]](https://www.youtube.com/watch?v=s6oLWpLj560&t=313s&ab_channel=KnowlliPop%EB%86%80%EB%A6%AC%ED%8C%9D)
